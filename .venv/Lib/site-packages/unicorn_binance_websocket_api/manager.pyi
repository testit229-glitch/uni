from .exceptions import *
import asyncio
import logging
import threading
from .api.api import WsApi as WsApi
from .connection_settings import CEX_EXCHANGES as CEX_EXCHANGES, CONNECTION_SETTINGS as CONNECTION_SETTINGS, DEX_EXCHANGES as DEX_EXCHANGES
from .restclient import BinanceWebSocketApiRestclient as BinanceWebSocketApiRestclient
from .restserver import BinanceWebSocketApiRestServer as BinanceWebSocketApiRestServer
from .sockets import BinanceWebSocketApiSocket as BinanceWebSocketApiSocket
from _typeshed import Incomplete
from typing import Callable, Literal
from unicorn_binance_rest_api import BinanceRestApiManager as BinanceRestApiManager
from unicorn_fy.unicorn_fy import UnicornFy

__app_name__: str
__version__: str
__logger__: logging.getLogger
logger = __logger__

class BinanceWebSocketApiManager(threading.Thread):
    name: Incomplete
    version: Incomplete
    stop_manager_request: bool
    auto_data_cleanup_stopped_streams: Incomplete
    debug: Incomplete
    ubra: Incomplete
    disable_colorama: Incomplete
    specific_process_asyncio_queue: Incomplete
    specific_process_stream_data: Incomplete
    specific_process_stream_data_async: Incomplete
    process_asyncio_queue: Incomplete
    process_stream_data: Incomplete
    process_stream_data_async: Incomplete
    process_stream_signals: Incomplete
    enable_stream_signal_buffer: Incomplete
    exchange: Incomplete
    stream_list: Incomplete
    stream_list_lock: Incomplete
    max_subscriptions_per_stream: Incomplete
    websocket_base_uri: Incomplete
    websocket_api_base_uri: Incomplete
    restful_base_uri: Incomplete
    exchange_type: Incomplete
    socks5_proxy_server: Incomplete
    socks5_proxy_address: Incomplete
    socks5_proxy_user: Incomplete
    socks5_proxy_pass: Incomplete
    socks5_proxy_port: Incomplete
    socks5_proxy_ssl_verification: Incomplete
    websocket_ssl_context: Incomplete
    asyncio_queue: Incomplete
    all_subscriptions_number: int
    binance_api_status: Incomplete
    dex_user_address: Incomplete
    event_loops: Incomplete
    frequent_checks_list: Incomplete
    frequent_checks_list_lock: Incomplete
    receiving_speed_average: int
    receiving_speed_peak: Incomplete
    high_performance: Incomplete
    keep_max_received_last_second_entries: int
    keepalive_streams_list: Incomplete
    last_entry_added_to_stream_buffer: int
    last_monitoring_check: Incomplete
    last_update_check_github: Incomplete
    last_update_check_github_check_command: Incomplete
    listen_key_refresh_interval: Incomplete
    max_send_messages_per_second: int
    max_send_messages_per_second_reserve: int
    most_receives_per_second: int
    monitoring_api_server: Incomplete
    monitoring_total_received_bytes: int
    monitoring_total_receives: int
    output_default: Incomplete
    process_response: Incomplete
    process_response_lock: Incomplete
    reconnects: int
    reconnects_lock: Incomplete
    request_id: int
    request_id_lock: Incomplete
    restart_timeout: Incomplete
    return_response: Incomplete
    return_response_lock: Incomplete
    ringbuffer_error: Incomplete
    ringbuffer_error_max_size: int
    ringbuffer_result: Incomplete
    ringbuffer_result_max_size: int
    show_secrets_in_logs: Incomplete
    start_time: Incomplete
    stream_buffer_maxlen: Incomplete
    stream_buffer: Incomplete
    stream_buffer_lock: Incomplete
    stream_buffer_locks: Incomplete
    stream_buffers: Incomplete
    stream_signal_buffer: Incomplete
    stream_signal_buffer_lock: Incomplete
    socket_is_ready: Incomplete
    sockets: Incomplete
    stream_threads: Incomplete
    total_received_bytes: int
    total_received_bytes_lock: Incomplete
    total_receives: int
    total_receives_lock: Incomplete
    total_transmitted: int
    total_transmitted_lock: Incomplete
    close_timeout_default: Incomplete
    ping_interval_default: Incomplete
    ping_timeout_default: Incomplete
    replacement_text: str
    api: Incomplete
    warn_on_update: Incomplete
    restclient: Incomplete
    def __init__(self, process_stream_data: Callable | None = None, process_stream_data_async: Callable | None = None, process_asyncio_queue: Callable | None = None, exchange: str = 'binance.com', warn_on_update: bool = True, restart_timeout: int = 6, show_secrets_in_logs: bool = False, output_default: Literal['dict', 'raw_data', 'UnicornFy'] | None = 'raw_data', enable_stream_signal_buffer: bool = False, disable_colorama: bool = False, stream_buffer_maxlen: int | None = None, process_stream_signals: Incomplete | None = None, close_timeout_default: int = 1, ping_interval_default: int = 5, ping_timeout_default: int = 10, high_performance: bool = False, debug: bool = False, restful_base_uri: str = None, websocket_base_uri: str = None, websocket_api_base_uri: str = None, max_subscriptions_per_stream: int | None = None, exchange_type: Literal['cex', 'dex', None] = None, socks5_proxy_server: str = None, socks5_proxy_user: str = None, socks5_proxy_pass: str = None, socks5_proxy_ssl_verification: bool = True, auto_data_cleanup_stopped_streams: bool = False, ubra_manager: BinanceRestApiManager = None) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, error_traceback: types.TracebackType | None) -> None: ...
    async def get_stream_data_from_asyncio_queue(self, stream_id: Incomplete | None = None): ...
    def asyncio_queue_task_done(self, stream_id: Incomplete | None = None) -> bool: ...
    def send_stream_signal(self, signal_type: Incomplete | None = None, stream_id: Incomplete | None = None, data_record: Incomplete | None = None, error_msg: Incomplete | None = None) -> bool: ...
    def send_with_stream(self, stream_id: str = None, payload: dict | str = None, timeout: float = 5.0) -> bool: ...
    def generate_signature(self, api_secret: Incomplete | None = None, data: Incomplete | None = None): ...
    @staticmethod
    def order_params(data): ...
    def add_payload_to_stream(self, stream_id: Incomplete | None = None, payload: dict = None): ...
    def add_to_ringbuffer_error(self, error): ...
    def add_to_ringbuffer_result(self, result): ...
    def add_to_stream_buffer(self, stream_data, stream_buffer_name: Literal[False] | str = False): ...
    def add_to_stream_signal_buffer(self, signal_type: Incomplete | None = None, stream_id: Incomplete | None = None, data_record: Incomplete | None = None, error_msg: Incomplete | None = None): ...
    def add_total_received_bytes(self, size) -> None: ...
    def clear_asyncio_queue(self, stream_id: str = None) -> bool: ...
    def clear_stream_buffer(self, stream_buffer_name: Literal[False] | str = False): ...
    def create_payload(self, stream_id, method, channels: Incomplete | None = None, markets: Incomplete | None = None): ...
    def create_stream(self, channels: str | list[str] | set[str] | None = None, markets: str | list[str] | set[str] | None = None, stream_label: str = None, stream_buffer_name: Literal[False] | str = False, api_key: str = None, api_secret: str = None, symbols: str | list[str] | set[str] | None = None, output: Literal['dict', 'raw_data', 'UnicornFy'] | None = None, ping_interval: int = None, ping_timeout: int = None, close_timeout: int = None, listen_key: str = None, keep_listen_key_alive: bool = True, stream_buffer_maxlen: int = None, api: bool = False, process_stream_data: Callable | None = None, process_stream_data_async: Callable | None = None, process_asyncio_queue: Callable | None = None): ...
    def create_websocket_uri(self, channels, markets, stream_id: Incomplete | None = None, symbols: Incomplete | None = None, api: bool = False): ...
    def delete_listen_key_by_stream_id(self, stream_id) -> bool: ...
    def delete_stream_from_stream_list(self, stream_id, timeout: float = 10.0) -> bool: ...
    def remove_all_data_of_stream_id(self, stream_id, timeout: float = 10.0) -> bool: ...
    @staticmethod
    def fill_up_space_left(demand_of_chars, string, filling: str = ' '): ...
    @staticmethod
    def fill_up_space_centered(demand_of_chars, string, filling: str = ' '): ...
    @staticmethod
    def fill_up_space_right(demand_of_chars, string, filling: str = ' '): ...
    def get_active_stream_list(self): ...
    def get_all_receives_last_second(self): ...
    def get_binance_api_status(self): ...
    def get_debug_log(self): ...
    @staticmethod
    def get_timestamp() -> int: ...
    @staticmethod
    def get_timestamp_unix() -> float: ...
    def get_used_weight(self): ...
    def get_current_receiving_speed(self, stream_id): ...
    def get_current_receiving_speed_global(self): ...
    @staticmethod
    def get_date_of_timestamp(timestamp): ...
    def get_errors_from_endpoints(self): ...
    def get_event_loop_by_stream_id(self, stream_id: str | bool | None = False) -> asyncio.AbstractEventLoop | None: ...
    def get_exchange(self): ...
    @staticmethod
    def get_human_bytesize(amount_bytes, suffix: str = ''): ...
    @staticmethod
    def get_human_uptime(uptime): ...
    @staticmethod
    def get_latest_release_info(): ...
    @staticmethod
    def get_latest_release_info_check_command(): ...
    def get_latest_version(self) -> str | None: ...
    def get_latest_version_check_command(self) -> str | None: ...
    def get_limit_of_subscriptions_per_stream(self): ...
    def get_number_of_all_subscriptions(self): ...
    def get_number_of_free_subscription_slots(self, stream_id): ...
    def get_listen_key_from_restclient(self, stream_id): ...
    def get_most_receives_per_second(self): ...
    def get_number_of_streams_in_stream_list(self): ...
    def get_number_of_subscriptions(self, stream_id): ...
    def get_keep_max_received_last_second_entries(self): ...
    def get_monitoring_status_icinga(self, check_command_version: bool = False, warn_on_update: bool = True): ...
    def get_monitoring_status_plain(self, check_command_version: bool = False, warn_on_update: bool = True): ...
    @staticmethod
    def get_new_uuid_id() -> str: ...
    def get_process_usage_memory(self): ...
    @staticmethod
    def get_process_usage_cpu(): ...
    @staticmethod
    def get_process_usage_threads(): ...
    def get_reconnects(self): ...
    def get_request_id(self): ...
    def get_result_by_request_id(self, request_id: Incomplete | None = None, timeout: int = 10): ...
    def get_results_from_endpoints(self): ...
    def get_ringbuffer_error_max_size(self): ...
    def get_ringbuffer_result_max_size(self): ...
    def get_start_time(self): ...
    def get_stream_buffer_byte_size(self): ...
    def get_stream_buffer_length(self, stream_buffer_name: Literal[False] | str = False): ...
    def get_stream_id_by_label(self, stream_label: str = None) -> str | None: ...
    def get_stream_info(self, stream_id): ...
    def get_stream_label(self, stream_id: Incomplete | None = None): ...
    def get_stream_subscriptions(self, stream_id, request_id: Incomplete | None = None): ...
    def get_stream_list(self): ...
    def get_stream_buffer_maxlen(self, stream_buffer_name: Literal[False] | str = False): ...
    def get_stream_receives_last_second(self, stream_id): ...
    def get_stream_statistic(self, stream_id): ...
    def get_the_one_active_websocket_api(self) -> str | None: ...
    def get_total_received_bytes(self): ...
    def get_total_receives(self): ...
    def get_user_agent(self): ...
    def get_version(self): ...
    @staticmethod
    def get_version_unicorn_fy(): ...
    @staticmethod
    def help() -> None: ...
    def increase_received_bytes_per_second(self, stream_id, size) -> None: ...
    def increase_processed_receives_statistic(self, stream_id): ...
    def increase_reconnect_counter(self, stream_id: Incomplete | None = None) -> None: ...
    def increase_transmitted_counter(self, stream_id) -> None: ...
    def is_manager_stopping(self): ...
    def is_exchange_type(self, exchange_type: str = None): ...
    def is_crash_request(self, stream_id) -> bool: ...
    def is_stop_request(self, stream_id) -> bool: ...
    def is_stream_signal_buffer_enabled(self): ...
    def is_update_available(self): ...
    @staticmethod
    def is_update_available_unicorn_fy(): ...
    def is_update_available_check_command(self, check_command_version: Incomplete | None = None): ...
    def pop_stream_data_from_stream_buffer(self, stream_buffer_name: Literal[False] | str = None, mode: str = 'FIFO'): ...
    def pop_stream_signal_from_stream_signal_buffer(self): ...
    def print_stream_info(self, stream_id: str = None, add_string: str = None, footer: str = None, title: str = None): ...
    def print_summary(self, add_string: str = None, disable_print: bool = False, footer: str = None, title: str = None): ...
    def print_summary_to_png(self, print_summary_export_path, height_per_row: float = 12.5, add_string: str = None, footer: str = None, title: str = None): ...
    @staticmethod
    def remove_ansi_escape_codes(text): ...
    def replace_stream(self, stream_id, new_channels, new_markets, new_stream_label: Incomplete | None = None, new_stream_buffer_name: Literal[False] | str = False, new_api_key: Incomplete | None = None, new_api_secret: Incomplete | None = None, new_symbols: Incomplete | None = None, new_output: Literal['dict', 'raw_data', 'UnicornFy'] | None = None, new_ping_interval: int = 20, new_ping_timeout: int = 20, new_close_timeout: int = 10, new_stream_buffer_maxlen: Incomplete | None = None): ...
    def run(self) -> None: ...
    def set_private_dex_config(self, binance_dex_user_address) -> None: ...
    def set_heartbeat(self, stream_id) -> None: ...
    def set_stop_request(self, stream_id: Incomplete | None = None): ...
    def set_ringbuffer_error_max_size(self, max_size) -> None: ...
    def set_ringbuffer_result_max_size(self, max_size) -> None: ...
    def is_socket_ready(self, stream_id: str = None) -> bool: ...
    def set_socket_is_not_ready(self, stream_id: str) -> bool: ...
    def set_socket_is_ready(self, stream_id: str) -> bool: ...
    def set_stream_label(self, stream_id, stream_label: Incomplete | None = None) -> bool: ...
    def set_keep_max_received_last_second_entries(self, number_of_max_entries) -> None: ...
    def split_payload(self, params, method, max_items_per_request: int = 350): ...
    def start_monitoring_api(self, host: str = '127.0.0.1', port: int = 64201, warn_on_update: bool = True): ...
    def stop_manager(self): ...
    def stop_manager_with_all_streams(self) -> None: ...
    def stop_monitoring_api(self) -> bool: ...
    def stop_stream(self, stream_id, delete_listen_key: bool = True): ...
    def subscribe_to_stream(self, stream_id: str = None, channels: Incomplete | None = None, markets: Incomplete | None = None) -> bool: ...
    def unsubscribe_from_stream(self, stream_id: str = None, channels: Incomplete | None = None, markets: Incomplete | None = None) -> bool: ...
    def wait_till_stream_has_started(self, stream_id, timeout: float = 0.0) -> bool: ...
    def wait_till_stream_has_stopped(self, stream_id: str = None, timeout: float = 0.0) -> bool: ...
